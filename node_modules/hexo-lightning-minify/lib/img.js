"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformImage = transformImage;
exports.replaceSrc = replaceSrc;
const node_path_1 = __importDefault(require("node:path"));
const promises_1 = __importDefault(require("fs/promises"));
const sharp_1 = __importDefault(require("sharp"));
const utils_1 = require("./utils");
const cheerio_1 = require("cheerio");
const node_crypto_1 = require("node:crypto");
const cacheDB_1 = require("./cacheDB");
async function streamToBuffer(stream) {
    return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on('data', (chunk) => {
            chunks.push(chunk);
        });
        stream.on('end', () => {
            const fullBuffer = Buffer.concat(chunks);
            resolve(fullBuffer);
        });
        stream.on('error', (err) => {
            reject(err);
        });
    });
}
const cacheDB = new cacheDB_1.CacheDB();
async function transformImage() {
    let transformedImageExt = '';
    const publicDir = this.public_dir;
    const { options, exclude } = this.config.minify.image;
    let sharpAvifOptions;
    let sharpWebpOptions;
    if (options.avif) {
        sharpAvifOptions = {
            effort: options.effort,
            lossless: false,
            quality: 60,
            chromaSubsampling: options.enableSubSampling ? '4:2:0' : '4:4:4',
        };
        if (options.quality === 'lossless') {
            sharpAvifOptions.lossless = true;
        }
        else if (options.quality === 'nearLossless') {
            throw new Error('nearLossless is not supported in avif format');
        }
        else {
            sharpAvifOptions.quality = options.quality;
        }
        transformedImageExt = '.avif';
    }
    else if (options.webp) {
        sharpWebpOptions = {
            effort: options.effort,
            lossless: false,
            nearLossless: false,
            smartSubsample: options.enableSubSampling,
            quality: 80,
        };
        if (options.quality === 'lossless') {
            sharpWebpOptions.lossless = true;
        }
        else if (options.quality === 'nearLossless') {
            sharpWebpOptions.nearLossless = true;
        }
        else {
            sharpWebpOptions.quality = options.quality;
        }
        transformedImageExt = '.webp';
    }
    else {
        throw new Error('No image format selected for conversion. Please enable either AVIF or WebP.');
    }
    const imagesPaths = this.route.list().filter(item => item.match(/\.(png|jpg|gif|jpeg)$/i));
    const streamsOfImages = imagesPaths.map(item => this.route.get(item));
    const images = imagesPaths.map((image, index) => ({
        path: image,
        stream: streamsOfImages[index],
        cached: false
    }));
    if (options.persistCache) {
        await cacheDB.readDB();
    }
    await Promise.all(images.map(async (image) => {
        if ((0, utils_1.isExclude)(image.path, exclude)) {
            return;
        }
        const sourceBuffer = await streamToBuffer(image.stream);
        const transformedPath = image.path.replace(/\.(png|jpg|gif|jpeg)$/i, transformedImageExt);
        const transformedImagePath = node_path_1.default.join(publicDir, transformedPath);
        if (options.persistCache) {
            const sourcePathHash = (0, node_crypto_1.createHash)('sha256').update(image.path).digest('hex');
            const sourceImageHash = (0, node_crypto_1.createHash)('sha256').update(sourceBuffer).digest('hex');
            const cachedHash = cacheDB.getImageHash(sourcePathHash);
            if (cachedHash && cachedHash === sourceImageHash) {
                const cacheImage = await promises_1.default.readFile(`./lightning-minify/images/${sourcePathHash}${transformedImageExt}`);
                this.route.set(transformedPath, cacheImage);
                image.cached = true;
                this.log.info(`Using cached image for ${image.path} (${cacheImage.length} bytes)`);
                return;
            }
            else {
                await cacheDB.setImageHash(sourcePathHash, sourceImageHash);
            }
        }
        if (!(await promises_1.default.access(transformedImagePath).catch(() => false))) {
            const sharpImage = (0, sharp_1.default)(sourceBuffer);
            const transformedSharp = options.webp ? sharpImage.webp(sharpWebpOptions) : sharpImage.avif(sharpAvifOptions);
            transformedSharp.toBuffer()
                .then(async (info) => {
                this.route.set(transformedPath, info);
                if (this.config.minify.image.options.destroyOldRoute) {
                    this.route.remove(image.path);
                }
                this.log.info(`Converted ${image.path} to ${transformedImageExt} (saved ${((sourceBuffer.length - info.length) / sourceBuffer.length * 100).toFixed(2)}%)`);
                if (options.persistCache) {
                    const sourcePathHash = (0, node_crypto_1.createHash)('sha256').update(image.path).digest('hex');
                    await promises_1.default.writeFile(`./lightning-minify/images/${sourcePathHash}${transformedImageExt}`, info);
                }
            })
                .catch((err) => {
                this.log.error(`Error converting ${image.path} to ${transformedImageExt}:`, err);
            });
        }
    }));
    if (options.persistCache) {
        await cacheDB.writeDB();
    }
}
const isLocalLink = function (hexo, origin, src) {
    if (src && src.startsWith('http'))
        return false;
    return (src && (src.startsWith('/') || src.startsWith('.') || new URL(src, hexo.config.url).origin === origin) && /\.(png|jpg|gif)$/.test(src));
};
function replaceSrc(str) {
    let transformedImageExt = '';
    if (this.config.minify.image.options.webp) {
        transformedImageExt = '.webp';
    }
    else if (this.config.minify.image.options.avif) {
        transformedImageExt = '.avif';
    }
    const $ = (0, cheerio_1.load)(str);
    const origin = new URL(this.config.url).origin;
    const hexo = this;
    function replaceLink(src) {
        const srcO = node_path_1.default.parse(src);
        return node_path_1.default.join(srcO.dir, srcO.name + transformedImageExt).replace(/\\/g, '/');
    }
    $('img').each(function () {
        const img = $(this);
        const src = img.attr('src');
        const dataSrc = img.attr('data-src');
        if (isLocalLink(hexo, origin, src) && typeof src !== 'undefined') {
            img.attr('src', replaceLink(src));
        }
        if (isLocalLink(hexo, origin, dataSrc) && typeof dataSrc !== 'undefined') {
            img.attr('data-src', replaceLink(dataSrc));
        }
    });
    $('div .cover').each(function () {
        const div = $(this);
        const dataBgImg = div.attr('data-background-image');
        if (isLocalLink(hexo, origin, dataBgImg) && typeof dataBgImg !== 'undefined') {
            div.attr('data-background-image', replaceLink(dataBgImg));
        }
    });
    return $.html();
}
